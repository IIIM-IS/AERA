; Similar to pong.2.replicode, but use the external environment in the TestMem class to
; intercept ejection of (cmd set_speed_y ...), simulate the motion of the ball, and inject
; a new (mk.val b: position_y ...) every sampling period.
; The model m_run_cmd abduces the goal to run a command to set the speed, and the program
; pgm_set_speed is called once to inject the drive to set a new speed.

;;;;;;;;;;;;;
;; objects ;;
b:(ent 1)
[
[]; view
   SYNC_ONCE; sync (synchronization mode)
   now;       injection time
   1;         saliency
   forever;   resilience
   root;      group
   nil;       origin
]; Set of views
ball:(ont 1) [[SYNC_ONCE now 0 forever root nil]]
b_is_a_ball:(mk.val b essence ball 1) |[]
; Even though (fact b_is_a_ball ::) is not used in this file, the pattern extractor needs it.
f_b_is_a_ball:(fact b_is_a_ball 0us MAX_TIME 1 1) [[SYNC_AXIOM now 1 forever stdin nil]]

;;;;;;;;;;;;;;;;;;;;;
;; Top-level model ;;
; From a RHS goal to have a velocity, abduce the LHS goal to run a command to set the velocity.
m_run_cmd:(mdl |[] []
   (fact (cmd set_velocity_y [b: velocity_y:] 1) t0: t1: 1 1)
   (fact (mk.val b: velocity_y velocity_y: :) t0: t1: ::); In abduction, matched as (fact (goal (fact ...)))
|[]
|[]
[stdin drives] 1 1 1 0 1) [[SYNC_ONCE now 0 forever primary nil 1]]

m_run_0:(mdl 
|[]; template arguments
[]; LHS and RHS patterns of the model
   (fact (mk.val b velocity_y 0.0002 1) t0: t1: 1 1); LHS
   (fact run t0: t1: ::);                 drive. RHS
|[]; forward guards
|[]; backward guards
[stdin drives]; output groups
1; strength of the model
1; number of evidences
1; success rate
0; derivative of the success rate
1; psln_tr (saliency change propagation threshold)
) [[SYNC_ONCE now 1 forever primary nil 1]]

;;;;;;;;;;;;;;;;;;;;;;
;; input generators ;;

; This program runs once to set the initial velocity_y at 0.0001.
start:(pgm |[] |[] |[] []
   (prb [1 "print" "starting..." |[]])
   ; Set the initial velocity in the external environment. This will inject velocity_y.
   (cmd set_velocity_y [b 0.0001] 1)
1) |[]

istart:(ipgm start |[] RUN_ONCE sampling_period VOLATILE NOTIFY 1) [[SYNC_ONCE now 0 forever stdin nil 1]]

; Run once to inject the drive that will abduce a goal to set a new velocity.
pgm_set_velocity:(pgm
|[]; template arguments
[];  patterns defining the inputs
   (ptn (fact (mk.val b position_y py: :) after: before: ::) |[])
[]; guards
   (> py 99); Don't run until py is 100.
[];  productions
   (inj []
      ; Delay a little to allow predictions for this sampling period before injecting the drive.
      f_run:(fact run (+ after 10000us) before 1 1)
      |[]
   )
   (inj []
      g:(goal f_run self nil 1)
      |[]
   )
   (inj []
      (fact g t1:(+ after 10000us) t1 1 1)
      [SYNC_ONCE t1 1 forever primary nil]
   )
   (prb [1 "print" "injected run" |[]])
1) |[]

i_pgm_set_velocity:(ipgm pgm_set_velocity |[] RUN_ONCE 20000us VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever stdin nil 1]

; This program intercepts an abduced goal to run a command and directly
; calls the command, which will call the override of _Mem::eject().
pgm_cmd_set_velocity_y:(pgm |[]
[]
   (ptn (fact g:(goal (fact c:(cmd set_velocity_y [obj: sy:] ::) ::) ::) ::) |[])
|[]
[]
   (= (is_sim g) false)
   (cmd set_velocity_y [obj sy] 1)
   (prb [1 "print" "cmd set_velocity_y" [c]])
1) |[]
i_pgm_cmd_set_velocity_y:(ipgm pgm_cmd_set_velocity_y |[] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever primary nil 1]; Use primary since abduced goals go in there.
