// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tcp_data_message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tcp_5fdata_5fmessage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tcp_5fdata_5fmessage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tcp_5fdata_5fmessage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tcp_5fdata_5fmessage_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tcp_5fdata_5fmessage_2eproto;
namespace tcp_io_device {
class CommandDescription;
struct CommandDescriptionDefaultTypeInternal;
extern CommandDescriptionDefaultTypeInternal _CommandDescription_default_instance_;
class DataMessage;
struct DataMessageDefaultTypeInternal;
extern DataMessageDefaultTypeInternal _DataMessage_default_instance_;
class ProtoVariable;
struct ProtoVariableDefaultTypeInternal;
extern ProtoVariableDefaultTypeInternal _ProtoVariable_default_instance_;
class SetupMessage;
struct SetupMessageDefaultTypeInternal;
extern SetupMessageDefaultTypeInternal _SetupMessage_default_instance_;
class SetupMessage_CommandsEntry_DoNotUse;
struct SetupMessage_CommandsEntry_DoNotUseDefaultTypeInternal;
extern SetupMessage_CommandsEntry_DoNotUseDefaultTypeInternal _SetupMessage_CommandsEntry_DoNotUse_default_instance_;
class SetupMessage_EntitiesEntry_DoNotUse;
struct SetupMessage_EntitiesEntry_DoNotUseDefaultTypeInternal;
extern SetupMessage_EntitiesEntry_DoNotUseDefaultTypeInternal _SetupMessage_EntitiesEntry_DoNotUse_default_instance_;
class SetupMessage_ObjectsEntry_DoNotUse;
struct SetupMessage_ObjectsEntry_DoNotUseDefaultTypeInternal;
extern SetupMessage_ObjectsEntry_DoNotUseDefaultTypeInternal _SetupMessage_ObjectsEntry_DoNotUse_default_instance_;
class StartMessage;
struct StartMessageDefaultTypeInternal;
extern StartMessageDefaultTypeInternal _StartMessage_default_instance_;
class StopMessage;
struct StopMessageDefaultTypeInternal;
extern StopMessageDefaultTypeInternal _StopMessage_default_instance_;
class TCPMessage;
struct TCPMessageDefaultTypeInternal;
extern TCPMessageDefaultTypeInternal _TCPMessage_default_instance_;
class VariableDescription;
struct VariableDescriptionDefaultTypeInternal;
extern VariableDescriptionDefaultTypeInternal _VariableDescription_default_instance_;
}  // namespace tcp_io_device
PROTOBUF_NAMESPACE_OPEN
template<> ::tcp_io_device::CommandDescription* Arena::CreateMaybeMessage<::tcp_io_device::CommandDescription>(Arena*);
template<> ::tcp_io_device::DataMessage* Arena::CreateMaybeMessage<::tcp_io_device::DataMessage>(Arena*);
template<> ::tcp_io_device::ProtoVariable* Arena::CreateMaybeMessage<::tcp_io_device::ProtoVariable>(Arena*);
template<> ::tcp_io_device::SetupMessage* Arena::CreateMaybeMessage<::tcp_io_device::SetupMessage>(Arena*);
template<> ::tcp_io_device::SetupMessage_CommandsEntry_DoNotUse* Arena::CreateMaybeMessage<::tcp_io_device::SetupMessage_CommandsEntry_DoNotUse>(Arena*);
template<> ::tcp_io_device::SetupMessage_EntitiesEntry_DoNotUse* Arena::CreateMaybeMessage<::tcp_io_device::SetupMessage_EntitiesEntry_DoNotUse>(Arena*);
template<> ::tcp_io_device::SetupMessage_ObjectsEntry_DoNotUse* Arena::CreateMaybeMessage<::tcp_io_device::SetupMessage_ObjectsEntry_DoNotUse>(Arena*);
template<> ::tcp_io_device::StartMessage* Arena::CreateMaybeMessage<::tcp_io_device::StartMessage>(Arena*);
template<> ::tcp_io_device::StopMessage* Arena::CreateMaybeMessage<::tcp_io_device::StopMessage>(Arena*);
template<> ::tcp_io_device::TCPMessage* Arena::CreateMaybeMessage<::tcp_io_device::TCPMessage>(Arena*);
template<> ::tcp_io_device::VariableDescription* Arena::CreateMaybeMessage<::tcp_io_device::VariableDescription>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tcp_io_device {

enum TCPMessage_Type : int {
  TCPMessage_Type_SETUP = 0,
  TCPMessage_Type_DATA = 1,
  TCPMessage_Type_START = 2,
  TCPMessage_Type_STOP = 3,
  TCPMessage_Type_TCPMessage_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TCPMessage_Type_TCPMessage_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TCPMessage_Type_IsValid(int value);
constexpr TCPMessage_Type TCPMessage_Type_Type_MIN = TCPMessage_Type_SETUP;
constexpr TCPMessage_Type TCPMessage_Type_Type_MAX = TCPMessage_Type_STOP;
constexpr int TCPMessage_Type_Type_ARRAYSIZE = TCPMessage_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TCPMessage_Type_descriptor();
template<typename T>
inline const std::string& TCPMessage_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TCPMessage_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TCPMessage_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TCPMessage_Type_descriptor(), enum_t_value);
}
inline bool TCPMessage_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TCPMessage_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TCPMessage_Type>(
    TCPMessage_Type_descriptor(), name, value);
}
enum VariableDescription_DataType : int {
  VariableDescription_DataType_DOUBLE = 0,
  VariableDescription_DataType_INT64 = 3,
  VariableDescription_DataType_BOOL = 12,
  VariableDescription_DataType_STRING = 13,
  VariableDescription_DataType_BYTES = 14,
  VariableDescription_DataType_VariableDescription_DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VariableDescription_DataType_VariableDescription_DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VariableDescription_DataType_IsValid(int value);
constexpr VariableDescription_DataType VariableDescription_DataType_DataType_MIN = VariableDescription_DataType_DOUBLE;
constexpr VariableDescription_DataType VariableDescription_DataType_DataType_MAX = VariableDescription_DataType_BYTES;
constexpr int VariableDescription_DataType_DataType_ARRAYSIZE = VariableDescription_DataType_DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VariableDescription_DataType_descriptor();
template<typename T>
inline const std::string& VariableDescription_DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VariableDescription_DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VariableDescription_DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VariableDescription_DataType_descriptor(), enum_t_value);
}
inline bool VariableDescription_DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VariableDescription_DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VariableDescription_DataType>(
    VariableDescription_DataType_descriptor(), name, value);
}
// ===================================================================

class TCPMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tcp_io_device.TCPMessage) */ {
 public:
  inline TCPMessage() : TCPMessage(nullptr) {}
  ~TCPMessage() override;
  explicit PROTOBUF_CONSTEXPR TCPMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TCPMessage(const TCPMessage& from);
  TCPMessage(TCPMessage&& from) noexcept
    : TCPMessage() {
    *this = ::std::move(from);
  }

  inline TCPMessage& operator=(const TCPMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TCPMessage& operator=(TCPMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TCPMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kSetupMessage = 2,
    kDataMessage = 3,
    kStartMessage = 4,
    kStopMessage = 5,
    MESSAGE_NOT_SET = 0,
  };

  static inline const TCPMessage* internal_default_instance() {
    return reinterpret_cast<const TCPMessage*>(
               &_TCPMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TCPMessage& a, TCPMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TCPMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TCPMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TCPMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TCPMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TCPMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TCPMessage& from) {
    TCPMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TCPMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tcp_io_device.TCPMessage";
  }
  protected:
  explicit TCPMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TCPMessage_Type Type;
  static constexpr Type SETUP =
    TCPMessage_Type_SETUP;
  static constexpr Type DATA =
    TCPMessage_Type_DATA;
  static constexpr Type START =
    TCPMessage_Type_START;
  static constexpr Type STOP =
    TCPMessage_Type_STOP;
  static inline bool Type_IsValid(int value) {
    return TCPMessage_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    TCPMessage_Type_Type_MIN;
  static constexpr Type Type_MAX =
    TCPMessage_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    TCPMessage_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return TCPMessage_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return TCPMessage_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return TCPMessage_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 6,
    kMessageTypeFieldNumber = 1,
    kSetupMessageFieldNumber = 2,
    kDataMessageFieldNumber = 3,
    kStartMessageFieldNumber = 4,
    kStopMessageFieldNumber = 5,
  };
  // uint64 timestamp = 6;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // .tcp_io_device.TCPMessage.Type messageType = 1;
  void clear_messagetype();
  ::tcp_io_device::TCPMessage_Type messagetype() const;
  void set_messagetype(::tcp_io_device::TCPMessage_Type value);
  private:
  ::tcp_io_device::TCPMessage_Type _internal_messagetype() const;
  void _internal_set_messagetype(::tcp_io_device::TCPMessage_Type value);
  public:

  // .tcp_io_device.SetupMessage setupMessage = 2;
  bool has_setupmessage() const;
  private:
  bool _internal_has_setupmessage() const;
  public:
  void clear_setupmessage();
  const ::tcp_io_device::SetupMessage& setupmessage() const;
  PROTOBUF_NODISCARD ::tcp_io_device::SetupMessage* release_setupmessage();
  ::tcp_io_device::SetupMessage* mutable_setupmessage();
  void set_allocated_setupmessage(::tcp_io_device::SetupMessage* setupmessage);
  private:
  const ::tcp_io_device::SetupMessage& _internal_setupmessage() const;
  ::tcp_io_device::SetupMessage* _internal_mutable_setupmessage();
  public:
  void unsafe_arena_set_allocated_setupmessage(
      ::tcp_io_device::SetupMessage* setupmessage);
  ::tcp_io_device::SetupMessage* unsafe_arena_release_setupmessage();

  // .tcp_io_device.DataMessage dataMessage = 3;
  bool has_datamessage() const;
  private:
  bool _internal_has_datamessage() const;
  public:
  void clear_datamessage();
  const ::tcp_io_device::DataMessage& datamessage() const;
  PROTOBUF_NODISCARD ::tcp_io_device::DataMessage* release_datamessage();
  ::tcp_io_device::DataMessage* mutable_datamessage();
  void set_allocated_datamessage(::tcp_io_device::DataMessage* datamessage);
  private:
  const ::tcp_io_device::DataMessage& _internal_datamessage() const;
  ::tcp_io_device::DataMessage* _internal_mutable_datamessage();
  public:
  void unsafe_arena_set_allocated_datamessage(
      ::tcp_io_device::DataMessage* datamessage);
  ::tcp_io_device::DataMessage* unsafe_arena_release_datamessage();

  // .tcp_io_device.StartMessage startMessage = 4;
  bool has_startmessage() const;
  private:
  bool _internal_has_startmessage() const;
  public:
  void clear_startmessage();
  const ::tcp_io_device::StartMessage& startmessage() const;
  PROTOBUF_NODISCARD ::tcp_io_device::StartMessage* release_startmessage();
  ::tcp_io_device::StartMessage* mutable_startmessage();
  void set_allocated_startmessage(::tcp_io_device::StartMessage* startmessage);
  private:
  const ::tcp_io_device::StartMessage& _internal_startmessage() const;
  ::tcp_io_device::StartMessage* _internal_mutable_startmessage();
  public:
  void unsafe_arena_set_allocated_startmessage(
      ::tcp_io_device::StartMessage* startmessage);
  ::tcp_io_device::StartMessage* unsafe_arena_release_startmessage();

  // .tcp_io_device.StopMessage stopMessage = 5;
  bool has_stopmessage() const;
  private:
  bool _internal_has_stopmessage() const;
  public:
  void clear_stopmessage();
  const ::tcp_io_device::StopMessage& stopmessage() const;
  PROTOBUF_NODISCARD ::tcp_io_device::StopMessage* release_stopmessage();
  ::tcp_io_device::StopMessage* mutable_stopmessage();
  void set_allocated_stopmessage(::tcp_io_device::StopMessage* stopmessage);
  private:
  const ::tcp_io_device::StopMessage& _internal_stopmessage() const;
  ::tcp_io_device::StopMessage* _internal_mutable_stopmessage();
  public:
  void unsafe_arena_set_allocated_stopmessage(
      ::tcp_io_device::StopMessage* stopmessage);
  ::tcp_io_device::StopMessage* unsafe_arena_release_stopmessage();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:tcp_io_device.TCPMessage)
 private:
  class _Internal;
  void set_has_setupmessage();
  void set_has_datamessage();
  void set_has_startmessage();
  void set_has_stopmessage();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t timestamp_;
    int messagetype_;
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::tcp_io_device::SetupMessage* setupmessage_;
      ::tcp_io_device::DataMessage* datamessage_;
      ::tcp_io_device::StartMessage* startmessage_;
      ::tcp_io_device::StopMessage* stopmessage_;
    } message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tcp_5fdata_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class StartMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tcp_io_device.StartMessage) */ {
 public:
  inline StartMessage() : StartMessage(nullptr) {}
  ~StartMessage() override;
  explicit PROTOBUF_CONSTEXPR StartMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartMessage(const StartMessage& from);
  StartMessage(StartMessage&& from) noexcept
    : StartMessage() {
    *this = ::std::move(from);
  }

  inline StartMessage& operator=(const StartMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartMessage& operator=(StartMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartMessage* internal_default_instance() {
    return reinterpret_cast<const StartMessage*>(
               &_StartMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StartMessage& a, StartMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StartMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartMessage& from) {
    StartMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tcp_io_device.StartMessage";
  }
  protected:
  explicit StartMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiagnosticModeFieldNumber = 1,
  };
  // bool diagnosticMode = 1;
  void clear_diagnosticmode();
  bool diagnosticmode() const;
  void set_diagnosticmode(bool value);
  private:
  bool _internal_diagnosticmode() const;
  void _internal_set_diagnosticmode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tcp_io_device.StartMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool diagnosticmode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tcp_5fdata_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class StopMessage final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tcp_io_device.StopMessage) */ {
 public:
  inline StopMessage() : StopMessage(nullptr) {}
  explicit PROTOBUF_CONSTEXPR StopMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopMessage(const StopMessage& from);
  StopMessage(StopMessage&& from) noexcept
    : StopMessage() {
    *this = ::std::move(from);
  }

  inline StopMessage& operator=(const StopMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopMessage& operator=(StopMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopMessage* internal_default_instance() {
    return reinterpret_cast<const StopMessage*>(
               &_StopMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StopMessage& a, StopMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StopMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopMessage& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopMessage& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tcp_io_device.StopMessage";
  }
  protected:
  explicit StopMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tcp_io_device.StopMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_tcp_5fdata_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class SetupMessage_EntitiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetupMessage_EntitiesEntry_DoNotUse, 
    std::string, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetupMessage_EntitiesEntry_DoNotUse, 
    std::string, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  SetupMessage_EntitiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SetupMessage_EntitiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SetupMessage_EntitiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SetupMessage_EntitiesEntry_DoNotUse& other);
  static const SetupMessage_EntitiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SetupMessage_EntitiesEntry_DoNotUse*>(&_SetupMessage_EntitiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "tcp_io_device.SetupMessage.EntitiesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tcp_5fdata_5fmessage_2eproto;
};

// -------------------------------------------------------------------

class SetupMessage_ObjectsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetupMessage_ObjectsEntry_DoNotUse, 
    std::string, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetupMessage_ObjectsEntry_DoNotUse, 
    std::string, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  SetupMessage_ObjectsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SetupMessage_ObjectsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SetupMessage_ObjectsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SetupMessage_ObjectsEntry_DoNotUse& other);
  static const SetupMessage_ObjectsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SetupMessage_ObjectsEntry_DoNotUse*>(&_SetupMessage_ObjectsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "tcp_io_device.SetupMessage.ObjectsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tcp_5fdata_5fmessage_2eproto;
};

// -------------------------------------------------------------------

class SetupMessage_CommandsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetupMessage_CommandsEntry_DoNotUse, 
    std::string, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetupMessage_CommandsEntry_DoNotUse, 
    std::string, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  SetupMessage_CommandsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SetupMessage_CommandsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SetupMessage_CommandsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SetupMessage_CommandsEntry_DoNotUse& other);
  static const SetupMessage_CommandsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SetupMessage_CommandsEntry_DoNotUse*>(&_SetupMessage_CommandsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "tcp_io_device.SetupMessage.CommandsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tcp_5fdata_5fmessage_2eproto;
};

// -------------------------------------------------------------------

class SetupMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tcp_io_device.SetupMessage) */ {
 public:
  inline SetupMessage() : SetupMessage(nullptr) {}
  ~SetupMessage() override;
  explicit PROTOBUF_CONSTEXPR SetupMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetupMessage(const SetupMessage& from);
  SetupMessage(SetupMessage&& from) noexcept
    : SetupMessage() {
    *this = ::std::move(from);
  }

  inline SetupMessage& operator=(const SetupMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetupMessage& operator=(SetupMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetupMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetupMessage* internal_default_instance() {
    return reinterpret_cast<const SetupMessage*>(
               &_SetupMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SetupMessage& a, SetupMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SetupMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetupMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetupMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetupMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetupMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetupMessage& from) {
    SetupMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetupMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tcp_io_device.SetupMessage";
  }
  protected:
  explicit SetupMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEntitiesFieldNumber = 1,
    kObjectsFieldNumber = 2,
    kCommandsFieldNumber = 3,
    kCommandDescriptionsFieldNumber = 4,
  };
  // map<string, int32> entities = 1;
  int entities_size() const;
  private:
  int _internal_entities_size() const;
  public:
  void clear_entities();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
      _internal_entities() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
      _internal_mutable_entities();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
      entities() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
      mutable_entities();

  // map<string, int32> objects = 2;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
      _internal_objects() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
      _internal_mutable_objects();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
      objects() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
      mutable_objects();

  // map<string, int32> commands = 3;
  int commands_size() const;
  private:
  int _internal_commands_size() const;
  public:
  void clear_commands();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
      _internal_commands() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
      _internal_mutable_commands();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
      commands() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
      mutable_commands();

  // repeated .tcp_io_device.CommandDescription commandDescriptions = 4;
  int commanddescriptions_size() const;
  private:
  int _internal_commanddescriptions_size() const;
  public:
  void clear_commanddescriptions();
  ::tcp_io_device::CommandDescription* mutable_commanddescriptions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tcp_io_device::CommandDescription >*
      mutable_commanddescriptions();
  private:
  const ::tcp_io_device::CommandDescription& _internal_commanddescriptions(int index) const;
  ::tcp_io_device::CommandDescription* _internal_add_commanddescriptions();
  public:
  const ::tcp_io_device::CommandDescription& commanddescriptions(int index) const;
  ::tcp_io_device::CommandDescription* add_commanddescriptions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tcp_io_device::CommandDescription >&
      commanddescriptions() const;

  // @@protoc_insertion_point(class_scope:tcp_io_device.SetupMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SetupMessage_EntitiesEntry_DoNotUse,
        std::string, int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> entities_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SetupMessage_ObjectsEntry_DoNotUse,
        std::string, int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> objects_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SetupMessage_CommandsEntry_DoNotUse,
        std::string, int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> commands_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tcp_io_device::CommandDescription > commanddescriptions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tcp_5fdata_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class CommandDescription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tcp_io_device.CommandDescription) */ {
 public:
  inline CommandDescription() : CommandDescription(nullptr) {}
  ~CommandDescription() override;
  explicit PROTOBUF_CONSTEXPR CommandDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandDescription(const CommandDescription& from);
  CommandDescription(CommandDescription&& from) noexcept
    : CommandDescription() {
    *this = ::std::move(from);
  }

  inline CommandDescription& operator=(const CommandDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandDescription& operator=(CommandDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandDescription* internal_default_instance() {
    return reinterpret_cast<const CommandDescription*>(
               &_CommandDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CommandDescription& a, CommandDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandDescription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommandDescription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommandDescription& from) {
    CommandDescription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tcp_io_device.CommandDescription";
  }
  protected:
  explicit CommandDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .tcp_io_device.VariableDescription description = 1;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const ::tcp_io_device::VariableDescription& description() const;
  PROTOBUF_NODISCARD ::tcp_io_device::VariableDescription* release_description();
  ::tcp_io_device::VariableDescription* mutable_description();
  void set_allocated_description(::tcp_io_device::VariableDescription* description);
  private:
  const ::tcp_io_device::VariableDescription& _internal_description() const;
  ::tcp_io_device::VariableDescription* _internal_mutable_description();
  public:
  void unsafe_arena_set_allocated_description(
      ::tcp_io_device::VariableDescription* description);
  ::tcp_io_device::VariableDescription* unsafe_arena_release_description();

  // @@protoc_insertion_point(class_scope:tcp_io_device.CommandDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::tcp_io_device::VariableDescription* description_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tcp_5fdata_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class DataMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tcp_io_device.DataMessage) */ {
 public:
  inline DataMessage() : DataMessage(nullptr) {}
  ~DataMessage() override;
  explicit PROTOBUF_CONSTEXPR DataMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMessage(const DataMessage& from);
  DataMessage(DataMessage&& from) noexcept
    : DataMessage() {
    *this = ::std::move(from);
  }

  inline DataMessage& operator=(const DataMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMessage& operator=(DataMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMessage* internal_default_instance() {
    return reinterpret_cast<const DataMessage*>(
               &_DataMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DataMessage& a, DataMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataMessage& from) {
    DataMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tcp_io_device.DataMessage";
  }
  protected:
  explicit DataMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVariablesFieldNumber = 1,
    kTimeSpanFieldNumber = 2,
  };
  // repeated .tcp_io_device.ProtoVariable variables = 1;
  int variables_size() const;
  private:
  int _internal_variables_size() const;
  public:
  void clear_variables();
  ::tcp_io_device::ProtoVariable* mutable_variables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tcp_io_device::ProtoVariable >*
      mutable_variables();
  private:
  const ::tcp_io_device::ProtoVariable& _internal_variables(int index) const;
  ::tcp_io_device::ProtoVariable* _internal_add_variables();
  public:
  const ::tcp_io_device::ProtoVariable& variables(int index) const;
  ::tcp_io_device::ProtoVariable* add_variables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tcp_io_device::ProtoVariable >&
      variables() const;

  // uint64 timeSpan = 2;
  void clear_timespan();
  uint64_t timespan() const;
  void set_timespan(uint64_t value);
  private:
  uint64_t _internal_timespan() const;
  void _internal_set_timespan(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tcp_io_device.DataMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tcp_io_device::ProtoVariable > variables_;
    uint64_t timespan_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tcp_5fdata_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class VariableDescription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tcp_io_device.VariableDescription) */ {
 public:
  inline VariableDescription() : VariableDescription(nullptr) {}
  ~VariableDescription() override;
  explicit PROTOBUF_CONSTEXPR VariableDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VariableDescription(const VariableDescription& from);
  VariableDescription(VariableDescription&& from) noexcept
    : VariableDescription() {
    *this = ::std::move(from);
  }

  inline VariableDescription& operator=(const VariableDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline VariableDescription& operator=(VariableDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VariableDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const VariableDescription* internal_default_instance() {
    return reinterpret_cast<const VariableDescription*>(
               &_VariableDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VariableDescription& a, VariableDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(VariableDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VariableDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VariableDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VariableDescription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VariableDescription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VariableDescription& from) {
    VariableDescription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VariableDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tcp_io_device.VariableDescription";
  }
  protected:
  explicit VariableDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VariableDescription_DataType DataType;
  static constexpr DataType DOUBLE =
    VariableDescription_DataType_DOUBLE;
  static constexpr DataType INT64 =
    VariableDescription_DataType_INT64;
  static constexpr DataType BOOL =
    VariableDescription_DataType_BOOL;
  static constexpr DataType STRING =
    VariableDescription_DataType_STRING;
  static constexpr DataType BYTES =
    VariableDescription_DataType_BYTES;
  static inline bool DataType_IsValid(int value) {
    return VariableDescription_DataType_IsValid(value);
  }
  static constexpr DataType DataType_MIN =
    VariableDescription_DataType_DataType_MIN;
  static constexpr DataType DataType_MAX =
    VariableDescription_DataType_DataType_MAX;
  static constexpr int DataType_ARRAYSIZE =
    VariableDescription_DataType_DataType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DataType_descriptor() {
    return VariableDescription_DataType_descriptor();
  }
  template<typename T>
  static inline const std::string& DataType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DataType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DataType_Name.");
    return VariableDescription_DataType_Name(enum_t_value);
  }
  static inline bool DataType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DataType* value) {
    return VariableDescription_DataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionsFieldNumber = 4,
    kEntityIDFieldNumber = 1,
    kIDFieldNumber = 2,
    kDataTypeFieldNumber = 3,
  };
  // repeated uint64 dimensions = 4;
  int dimensions_size() const;
  private:
  int _internal_dimensions_size() const;
  public:
  void clear_dimensions();
  private:
  uint64_t _internal_dimensions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_dimensions() const;
  void _internal_add_dimensions(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_dimensions();
  public:
  uint64_t dimensions(int index) const;
  void set_dimensions(int index, uint64_t value);
  void add_dimensions(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      dimensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_dimensions();

  // int32 entityID = 1;
  void clear_entityid();
  int32_t entityid() const;
  void set_entityid(int32_t value);
  private:
  int32_t _internal_entityid() const;
  void _internal_set_entityid(int32_t value);
  public:

  // int32 ID = 2;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // .tcp_io_device.VariableDescription.DataType dataType = 3;
  void clear_datatype();
  ::tcp_io_device::VariableDescription_DataType datatype() const;
  void set_datatype(::tcp_io_device::VariableDescription_DataType value);
  private:
  ::tcp_io_device::VariableDescription_DataType _internal_datatype() const;
  void _internal_set_datatype(::tcp_io_device::VariableDescription_DataType value);
  public:

  // @@protoc_insertion_point(class_scope:tcp_io_device.VariableDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > dimensions_;
    mutable std::atomic<int> _dimensions_cached_byte_size_;
    int32_t entityid_;
    int32_t id_;
    int datatype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tcp_5fdata_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class ProtoVariable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tcp_io_device.ProtoVariable) */ {
 public:
  inline ProtoVariable() : ProtoVariable(nullptr) {}
  ~ProtoVariable() override;
  explicit PROTOBUF_CONSTEXPR ProtoVariable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtoVariable(const ProtoVariable& from);
  ProtoVariable(ProtoVariable&& from) noexcept
    : ProtoVariable() {
    *this = ::std::move(from);
  }

  inline ProtoVariable& operator=(const ProtoVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoVariable& operator=(ProtoVariable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoVariable& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtoVariable* internal_default_instance() {
    return reinterpret_cast<const ProtoVariable*>(
               &_ProtoVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ProtoVariable& a, ProtoVariable& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtoVariable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoVariable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoVariable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtoVariable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtoVariable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtoVariable& from) {
    ProtoVariable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoVariable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tcp_io_device.ProtoVariable";
  }
  protected:
  explicit ProtoVariable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kMetaDataFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .tcp_io_device.VariableDescription metaData = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::tcp_io_device::VariableDescription& metadata() const;
  PROTOBUF_NODISCARD ::tcp_io_device::VariableDescription* release_metadata();
  ::tcp_io_device::VariableDescription* mutable_metadata();
  void set_allocated_metadata(::tcp_io_device::VariableDescription* metadata);
  private:
  const ::tcp_io_device::VariableDescription& _internal_metadata() const;
  ::tcp_io_device::VariableDescription* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::tcp_io_device::VariableDescription* metadata);
  ::tcp_io_device::VariableDescription* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:tcp_io_device.ProtoVariable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::tcp_io_device::VariableDescription* metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tcp_5fdata_5fmessage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TCPMessage

// .tcp_io_device.TCPMessage.Type messageType = 1;
inline void TCPMessage::clear_messagetype() {
  _impl_.messagetype_ = 0;
}
inline ::tcp_io_device::TCPMessage_Type TCPMessage::_internal_messagetype() const {
  return static_cast< ::tcp_io_device::TCPMessage_Type >(_impl_.messagetype_);
}
inline ::tcp_io_device::TCPMessage_Type TCPMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:tcp_io_device.TCPMessage.messageType)
  return _internal_messagetype();
}
inline void TCPMessage::_internal_set_messagetype(::tcp_io_device::TCPMessage_Type value) {
  
  _impl_.messagetype_ = value;
}
inline void TCPMessage::set_messagetype(::tcp_io_device::TCPMessage_Type value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:tcp_io_device.TCPMessage.messageType)
}

// .tcp_io_device.SetupMessage setupMessage = 2;
inline bool TCPMessage::_internal_has_setupmessage() const {
  return message_case() == kSetupMessage;
}
inline bool TCPMessage::has_setupmessage() const {
  return _internal_has_setupmessage();
}
inline void TCPMessage::set_has_setupmessage() {
  _impl_._oneof_case_[0] = kSetupMessage;
}
inline void TCPMessage::clear_setupmessage() {
  if (_internal_has_setupmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.setupmessage_;
    }
    clear_has_message();
  }
}
inline ::tcp_io_device::SetupMessage* TCPMessage::release_setupmessage() {
  // @@protoc_insertion_point(field_release:tcp_io_device.TCPMessage.setupMessage)
  if (_internal_has_setupmessage()) {
    clear_has_message();
    ::tcp_io_device::SetupMessage* temp = _impl_.message_.setupmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.setupmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tcp_io_device::SetupMessage& TCPMessage::_internal_setupmessage() const {
  return _internal_has_setupmessage()
      ? *_impl_.message_.setupmessage_
      : reinterpret_cast< ::tcp_io_device::SetupMessage&>(::tcp_io_device::_SetupMessage_default_instance_);
}
inline const ::tcp_io_device::SetupMessage& TCPMessage::setupmessage() const {
  // @@protoc_insertion_point(field_get:tcp_io_device.TCPMessage.setupMessage)
  return _internal_setupmessage();
}
inline ::tcp_io_device::SetupMessage* TCPMessage::unsafe_arena_release_setupmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tcp_io_device.TCPMessage.setupMessage)
  if (_internal_has_setupmessage()) {
    clear_has_message();
    ::tcp_io_device::SetupMessage* temp = _impl_.message_.setupmessage_;
    _impl_.message_.setupmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TCPMessage::unsafe_arena_set_allocated_setupmessage(::tcp_io_device::SetupMessage* setupmessage) {
  clear_message();
  if (setupmessage) {
    set_has_setupmessage();
    _impl_.message_.setupmessage_ = setupmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tcp_io_device.TCPMessage.setupMessage)
}
inline ::tcp_io_device::SetupMessage* TCPMessage::_internal_mutable_setupmessage() {
  if (!_internal_has_setupmessage()) {
    clear_message();
    set_has_setupmessage();
    _impl_.message_.setupmessage_ = CreateMaybeMessage< ::tcp_io_device::SetupMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.setupmessage_;
}
inline ::tcp_io_device::SetupMessage* TCPMessage::mutable_setupmessage() {
  ::tcp_io_device::SetupMessage* _msg = _internal_mutable_setupmessage();
  // @@protoc_insertion_point(field_mutable:tcp_io_device.TCPMessage.setupMessage)
  return _msg;
}

// .tcp_io_device.DataMessage dataMessage = 3;
inline bool TCPMessage::_internal_has_datamessage() const {
  return message_case() == kDataMessage;
}
inline bool TCPMessage::has_datamessage() const {
  return _internal_has_datamessage();
}
inline void TCPMessage::set_has_datamessage() {
  _impl_._oneof_case_[0] = kDataMessage;
}
inline void TCPMessage::clear_datamessage() {
  if (_internal_has_datamessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.datamessage_;
    }
    clear_has_message();
  }
}
inline ::tcp_io_device::DataMessage* TCPMessage::release_datamessage() {
  // @@protoc_insertion_point(field_release:tcp_io_device.TCPMessage.dataMessage)
  if (_internal_has_datamessage()) {
    clear_has_message();
    ::tcp_io_device::DataMessage* temp = _impl_.message_.datamessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.datamessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tcp_io_device::DataMessage& TCPMessage::_internal_datamessage() const {
  return _internal_has_datamessage()
      ? *_impl_.message_.datamessage_
      : reinterpret_cast< ::tcp_io_device::DataMessage&>(::tcp_io_device::_DataMessage_default_instance_);
}
inline const ::tcp_io_device::DataMessage& TCPMessage::datamessage() const {
  // @@protoc_insertion_point(field_get:tcp_io_device.TCPMessage.dataMessage)
  return _internal_datamessage();
}
inline ::tcp_io_device::DataMessage* TCPMessage::unsafe_arena_release_datamessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tcp_io_device.TCPMessage.dataMessage)
  if (_internal_has_datamessage()) {
    clear_has_message();
    ::tcp_io_device::DataMessage* temp = _impl_.message_.datamessage_;
    _impl_.message_.datamessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TCPMessage::unsafe_arena_set_allocated_datamessage(::tcp_io_device::DataMessage* datamessage) {
  clear_message();
  if (datamessage) {
    set_has_datamessage();
    _impl_.message_.datamessage_ = datamessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tcp_io_device.TCPMessage.dataMessage)
}
inline ::tcp_io_device::DataMessage* TCPMessage::_internal_mutable_datamessage() {
  if (!_internal_has_datamessage()) {
    clear_message();
    set_has_datamessage();
    _impl_.message_.datamessage_ = CreateMaybeMessage< ::tcp_io_device::DataMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.datamessage_;
}
inline ::tcp_io_device::DataMessage* TCPMessage::mutable_datamessage() {
  ::tcp_io_device::DataMessage* _msg = _internal_mutable_datamessage();
  // @@protoc_insertion_point(field_mutable:tcp_io_device.TCPMessage.dataMessage)
  return _msg;
}

// .tcp_io_device.StartMessage startMessage = 4;
inline bool TCPMessage::_internal_has_startmessage() const {
  return message_case() == kStartMessage;
}
inline bool TCPMessage::has_startmessage() const {
  return _internal_has_startmessage();
}
inline void TCPMessage::set_has_startmessage() {
  _impl_._oneof_case_[0] = kStartMessage;
}
inline void TCPMessage::clear_startmessage() {
  if (_internal_has_startmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.startmessage_;
    }
    clear_has_message();
  }
}
inline ::tcp_io_device::StartMessage* TCPMessage::release_startmessage() {
  // @@protoc_insertion_point(field_release:tcp_io_device.TCPMessage.startMessage)
  if (_internal_has_startmessage()) {
    clear_has_message();
    ::tcp_io_device::StartMessage* temp = _impl_.message_.startmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.startmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tcp_io_device::StartMessage& TCPMessage::_internal_startmessage() const {
  return _internal_has_startmessage()
      ? *_impl_.message_.startmessage_
      : reinterpret_cast< ::tcp_io_device::StartMessage&>(::tcp_io_device::_StartMessage_default_instance_);
}
inline const ::tcp_io_device::StartMessage& TCPMessage::startmessage() const {
  // @@protoc_insertion_point(field_get:tcp_io_device.TCPMessage.startMessage)
  return _internal_startmessage();
}
inline ::tcp_io_device::StartMessage* TCPMessage::unsafe_arena_release_startmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tcp_io_device.TCPMessage.startMessage)
  if (_internal_has_startmessage()) {
    clear_has_message();
    ::tcp_io_device::StartMessage* temp = _impl_.message_.startmessage_;
    _impl_.message_.startmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TCPMessage::unsafe_arena_set_allocated_startmessage(::tcp_io_device::StartMessage* startmessage) {
  clear_message();
  if (startmessage) {
    set_has_startmessage();
    _impl_.message_.startmessage_ = startmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tcp_io_device.TCPMessage.startMessage)
}
inline ::tcp_io_device::StartMessage* TCPMessage::_internal_mutable_startmessage() {
  if (!_internal_has_startmessage()) {
    clear_message();
    set_has_startmessage();
    _impl_.message_.startmessage_ = CreateMaybeMessage< ::tcp_io_device::StartMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.startmessage_;
}
inline ::tcp_io_device::StartMessage* TCPMessage::mutable_startmessage() {
  ::tcp_io_device::StartMessage* _msg = _internal_mutable_startmessage();
  // @@protoc_insertion_point(field_mutable:tcp_io_device.TCPMessage.startMessage)
  return _msg;
}

// .tcp_io_device.StopMessage stopMessage = 5;
inline bool TCPMessage::_internal_has_stopmessage() const {
  return message_case() == kStopMessage;
}
inline bool TCPMessage::has_stopmessage() const {
  return _internal_has_stopmessage();
}
inline void TCPMessage::set_has_stopmessage() {
  _impl_._oneof_case_[0] = kStopMessage;
}
inline void TCPMessage::clear_stopmessage() {
  if (_internal_has_stopmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.stopmessage_;
    }
    clear_has_message();
  }
}
inline ::tcp_io_device::StopMessage* TCPMessage::release_stopmessage() {
  // @@protoc_insertion_point(field_release:tcp_io_device.TCPMessage.stopMessage)
  if (_internal_has_stopmessage()) {
    clear_has_message();
    ::tcp_io_device::StopMessage* temp = _impl_.message_.stopmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.stopmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tcp_io_device::StopMessage& TCPMessage::_internal_stopmessage() const {
  return _internal_has_stopmessage()
      ? *_impl_.message_.stopmessage_
      : reinterpret_cast< ::tcp_io_device::StopMessage&>(::tcp_io_device::_StopMessage_default_instance_);
}
inline const ::tcp_io_device::StopMessage& TCPMessage::stopmessage() const {
  // @@protoc_insertion_point(field_get:tcp_io_device.TCPMessage.stopMessage)
  return _internal_stopmessage();
}
inline ::tcp_io_device::StopMessage* TCPMessage::unsafe_arena_release_stopmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tcp_io_device.TCPMessage.stopMessage)
  if (_internal_has_stopmessage()) {
    clear_has_message();
    ::tcp_io_device::StopMessage* temp = _impl_.message_.stopmessage_;
    _impl_.message_.stopmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TCPMessage::unsafe_arena_set_allocated_stopmessage(::tcp_io_device::StopMessage* stopmessage) {
  clear_message();
  if (stopmessage) {
    set_has_stopmessage();
    _impl_.message_.stopmessage_ = stopmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tcp_io_device.TCPMessage.stopMessage)
}
inline ::tcp_io_device::StopMessage* TCPMessage::_internal_mutable_stopmessage() {
  if (!_internal_has_stopmessage()) {
    clear_message();
    set_has_stopmessage();
    _impl_.message_.stopmessage_ = CreateMaybeMessage< ::tcp_io_device::StopMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.stopmessage_;
}
inline ::tcp_io_device::StopMessage* TCPMessage::mutable_stopmessage() {
  ::tcp_io_device::StopMessage* _msg = _internal_mutable_stopmessage();
  // @@protoc_insertion_point(field_mutable:tcp_io_device.TCPMessage.stopMessage)
  return _msg;
}

// uint64 timestamp = 6;
inline void TCPMessage::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t TCPMessage::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t TCPMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:tcp_io_device.TCPMessage.timestamp)
  return _internal_timestamp();
}
inline void TCPMessage::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void TCPMessage::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:tcp_io_device.TCPMessage.timestamp)
}

inline bool TCPMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void TCPMessage::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline TCPMessage::MessageCase TCPMessage::message_case() const {
  return TCPMessage::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StartMessage

// bool diagnosticMode = 1;
inline void StartMessage::clear_diagnosticmode() {
  _impl_.diagnosticmode_ = false;
}
inline bool StartMessage::_internal_diagnosticmode() const {
  return _impl_.diagnosticmode_;
}
inline bool StartMessage::diagnosticmode() const {
  // @@protoc_insertion_point(field_get:tcp_io_device.StartMessage.diagnosticMode)
  return _internal_diagnosticmode();
}
inline void StartMessage::_internal_set_diagnosticmode(bool value) {
  
  _impl_.diagnosticmode_ = value;
}
inline void StartMessage::set_diagnosticmode(bool value) {
  _internal_set_diagnosticmode(value);
  // @@protoc_insertion_point(field_set:tcp_io_device.StartMessage.diagnosticMode)
}

// -------------------------------------------------------------------

// StopMessage

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SetupMessage

// map<string, int32> entities = 1;
inline int SetupMessage::_internal_entities_size() const {
  return _impl_.entities_.size();
}
inline int SetupMessage::entities_size() const {
  return _internal_entities_size();
}
inline void SetupMessage::clear_entities() {
  _impl_.entities_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
SetupMessage::_internal_entities() const {
  return _impl_.entities_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
SetupMessage::entities() const {
  // @@protoc_insertion_point(field_map:tcp_io_device.SetupMessage.entities)
  return _internal_entities();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
SetupMessage::_internal_mutable_entities() {
  return _impl_.entities_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
SetupMessage::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_map:tcp_io_device.SetupMessage.entities)
  return _internal_mutable_entities();
}

// map<string, int32> objects = 2;
inline int SetupMessage::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int SetupMessage::objects_size() const {
  return _internal_objects_size();
}
inline void SetupMessage::clear_objects() {
  _impl_.objects_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
SetupMessage::_internal_objects() const {
  return _impl_.objects_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
SetupMessage::objects() const {
  // @@protoc_insertion_point(field_map:tcp_io_device.SetupMessage.objects)
  return _internal_objects();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
SetupMessage::_internal_mutable_objects() {
  return _impl_.objects_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
SetupMessage::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_map:tcp_io_device.SetupMessage.objects)
  return _internal_mutable_objects();
}

// map<string, int32> commands = 3;
inline int SetupMessage::_internal_commands_size() const {
  return _impl_.commands_.size();
}
inline int SetupMessage::commands_size() const {
  return _internal_commands_size();
}
inline void SetupMessage::clear_commands() {
  _impl_.commands_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
SetupMessage::_internal_commands() const {
  return _impl_.commands_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >&
SetupMessage::commands() const {
  // @@protoc_insertion_point(field_map:tcp_io_device.SetupMessage.commands)
  return _internal_commands();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
SetupMessage::_internal_mutable_commands() {
  return _impl_.commands_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int32_t >*
SetupMessage::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_map:tcp_io_device.SetupMessage.commands)
  return _internal_mutable_commands();
}

// repeated .tcp_io_device.CommandDescription commandDescriptions = 4;
inline int SetupMessage::_internal_commanddescriptions_size() const {
  return _impl_.commanddescriptions_.size();
}
inline int SetupMessage::commanddescriptions_size() const {
  return _internal_commanddescriptions_size();
}
inline void SetupMessage::clear_commanddescriptions() {
  _impl_.commanddescriptions_.Clear();
}
inline ::tcp_io_device::CommandDescription* SetupMessage::mutable_commanddescriptions(int index) {
  // @@protoc_insertion_point(field_mutable:tcp_io_device.SetupMessage.commandDescriptions)
  return _impl_.commanddescriptions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tcp_io_device::CommandDescription >*
SetupMessage::mutable_commanddescriptions() {
  // @@protoc_insertion_point(field_mutable_list:tcp_io_device.SetupMessage.commandDescriptions)
  return &_impl_.commanddescriptions_;
}
inline const ::tcp_io_device::CommandDescription& SetupMessage::_internal_commanddescriptions(int index) const {
  return _impl_.commanddescriptions_.Get(index);
}
inline const ::tcp_io_device::CommandDescription& SetupMessage::commanddescriptions(int index) const {
  // @@protoc_insertion_point(field_get:tcp_io_device.SetupMessage.commandDescriptions)
  return _internal_commanddescriptions(index);
}
inline ::tcp_io_device::CommandDescription* SetupMessage::_internal_add_commanddescriptions() {
  return _impl_.commanddescriptions_.Add();
}
inline ::tcp_io_device::CommandDescription* SetupMessage::add_commanddescriptions() {
  ::tcp_io_device::CommandDescription* _add = _internal_add_commanddescriptions();
  // @@protoc_insertion_point(field_add:tcp_io_device.SetupMessage.commandDescriptions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tcp_io_device::CommandDescription >&
SetupMessage::commanddescriptions() const {
  // @@protoc_insertion_point(field_list:tcp_io_device.SetupMessage.commandDescriptions)
  return _impl_.commanddescriptions_;
}

// -------------------------------------------------------------------

// CommandDescription

// .tcp_io_device.VariableDescription description = 1;
inline bool CommandDescription::_internal_has_description() const {
  return this != internal_default_instance() && _impl_.description_ != nullptr;
}
inline bool CommandDescription::has_description() const {
  return _internal_has_description();
}
inline void CommandDescription::clear_description() {
  if (GetArenaForAllocation() == nullptr && _impl_.description_ != nullptr) {
    delete _impl_.description_;
  }
  _impl_.description_ = nullptr;
}
inline const ::tcp_io_device::VariableDescription& CommandDescription::_internal_description() const {
  const ::tcp_io_device::VariableDescription* p = _impl_.description_;
  return p != nullptr ? *p : reinterpret_cast<const ::tcp_io_device::VariableDescription&>(
      ::tcp_io_device::_VariableDescription_default_instance_);
}
inline const ::tcp_io_device::VariableDescription& CommandDescription::description() const {
  // @@protoc_insertion_point(field_get:tcp_io_device.CommandDescription.description)
  return _internal_description();
}
inline void CommandDescription::unsafe_arena_set_allocated_description(
    ::tcp_io_device::VariableDescription* description) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.description_);
  }
  _impl_.description_ = description;
  if (description) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tcp_io_device.CommandDescription.description)
}
inline ::tcp_io_device::VariableDescription* CommandDescription::release_description() {
  
  ::tcp_io_device::VariableDescription* temp = _impl_.description_;
  _impl_.description_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tcp_io_device::VariableDescription* CommandDescription::unsafe_arena_release_description() {
  // @@protoc_insertion_point(field_release:tcp_io_device.CommandDescription.description)
  
  ::tcp_io_device::VariableDescription* temp = _impl_.description_;
  _impl_.description_ = nullptr;
  return temp;
}
inline ::tcp_io_device::VariableDescription* CommandDescription::_internal_mutable_description() {
  
  if (_impl_.description_ == nullptr) {
    auto* p = CreateMaybeMessage<::tcp_io_device::VariableDescription>(GetArenaForAllocation());
    _impl_.description_ = p;
  }
  return _impl_.description_;
}
inline ::tcp_io_device::VariableDescription* CommandDescription::mutable_description() {
  ::tcp_io_device::VariableDescription* _msg = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:tcp_io_device.CommandDescription.description)
  return _msg;
}
inline void CommandDescription::set_allocated_description(::tcp_io_device::VariableDescription* description) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.description_;
  }
  if (description) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(description);
    if (message_arena != submessage_arena) {
      description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, description, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.description_ = description;
  // @@protoc_insertion_point(field_set_allocated:tcp_io_device.CommandDescription.description)
}

// string name = 2;
inline void CommandDescription::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CommandDescription::name() const {
  // @@protoc_insertion_point(field_get:tcp_io_device.CommandDescription.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandDescription::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tcp_io_device.CommandDescription.name)
}
inline std::string* CommandDescription::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tcp_io_device.CommandDescription.name)
  return _s;
}
inline const std::string& CommandDescription::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CommandDescription::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CommandDescription::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CommandDescription::release_name() {
  // @@protoc_insertion_point(field_release:tcp_io_device.CommandDescription.name)
  return _impl_.name_.Release();
}
inline void CommandDescription::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tcp_io_device.CommandDescription.name)
}

// -------------------------------------------------------------------

// DataMessage

// repeated .tcp_io_device.ProtoVariable variables = 1;
inline int DataMessage::_internal_variables_size() const {
  return _impl_.variables_.size();
}
inline int DataMessage::variables_size() const {
  return _internal_variables_size();
}
inline void DataMessage::clear_variables() {
  _impl_.variables_.Clear();
}
inline ::tcp_io_device::ProtoVariable* DataMessage::mutable_variables(int index) {
  // @@protoc_insertion_point(field_mutable:tcp_io_device.DataMessage.variables)
  return _impl_.variables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tcp_io_device::ProtoVariable >*
DataMessage::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_list:tcp_io_device.DataMessage.variables)
  return &_impl_.variables_;
}
inline const ::tcp_io_device::ProtoVariable& DataMessage::_internal_variables(int index) const {
  return _impl_.variables_.Get(index);
}
inline const ::tcp_io_device::ProtoVariable& DataMessage::variables(int index) const {
  // @@protoc_insertion_point(field_get:tcp_io_device.DataMessage.variables)
  return _internal_variables(index);
}
inline ::tcp_io_device::ProtoVariable* DataMessage::_internal_add_variables() {
  return _impl_.variables_.Add();
}
inline ::tcp_io_device::ProtoVariable* DataMessage::add_variables() {
  ::tcp_io_device::ProtoVariable* _add = _internal_add_variables();
  // @@protoc_insertion_point(field_add:tcp_io_device.DataMessage.variables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tcp_io_device::ProtoVariable >&
DataMessage::variables() const {
  // @@protoc_insertion_point(field_list:tcp_io_device.DataMessage.variables)
  return _impl_.variables_;
}

// uint64 timeSpan = 2;
inline void DataMessage::clear_timespan() {
  _impl_.timespan_ = uint64_t{0u};
}
inline uint64_t DataMessage::_internal_timespan() const {
  return _impl_.timespan_;
}
inline uint64_t DataMessage::timespan() const {
  // @@protoc_insertion_point(field_get:tcp_io_device.DataMessage.timeSpan)
  return _internal_timespan();
}
inline void DataMessage::_internal_set_timespan(uint64_t value) {
  
  _impl_.timespan_ = value;
}
inline void DataMessage::set_timespan(uint64_t value) {
  _internal_set_timespan(value);
  // @@protoc_insertion_point(field_set:tcp_io_device.DataMessage.timeSpan)
}

// -------------------------------------------------------------------

// VariableDescription

// int32 entityID = 1;
inline void VariableDescription::clear_entityid() {
  _impl_.entityid_ = 0;
}
inline int32_t VariableDescription::_internal_entityid() const {
  return _impl_.entityid_;
}
inline int32_t VariableDescription::entityid() const {
  // @@protoc_insertion_point(field_get:tcp_io_device.VariableDescription.entityID)
  return _internal_entityid();
}
inline void VariableDescription::_internal_set_entityid(int32_t value) {
  
  _impl_.entityid_ = value;
}
inline void VariableDescription::set_entityid(int32_t value) {
  _internal_set_entityid(value);
  // @@protoc_insertion_point(field_set:tcp_io_device.VariableDescription.entityID)
}

// int32 ID = 2;
inline void VariableDescription::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t VariableDescription::_internal_id() const {
  return _impl_.id_;
}
inline int32_t VariableDescription::id() const {
  // @@protoc_insertion_point(field_get:tcp_io_device.VariableDescription.ID)
  return _internal_id();
}
inline void VariableDescription::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void VariableDescription::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tcp_io_device.VariableDescription.ID)
}

// .tcp_io_device.VariableDescription.DataType dataType = 3;
inline void VariableDescription::clear_datatype() {
  _impl_.datatype_ = 0;
}
inline ::tcp_io_device::VariableDescription_DataType VariableDescription::_internal_datatype() const {
  return static_cast< ::tcp_io_device::VariableDescription_DataType >(_impl_.datatype_);
}
inline ::tcp_io_device::VariableDescription_DataType VariableDescription::datatype() const {
  // @@protoc_insertion_point(field_get:tcp_io_device.VariableDescription.dataType)
  return _internal_datatype();
}
inline void VariableDescription::_internal_set_datatype(::tcp_io_device::VariableDescription_DataType value) {
  
  _impl_.datatype_ = value;
}
inline void VariableDescription::set_datatype(::tcp_io_device::VariableDescription_DataType value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:tcp_io_device.VariableDescription.dataType)
}

// repeated uint64 dimensions = 4;
inline int VariableDescription::_internal_dimensions_size() const {
  return _impl_.dimensions_.size();
}
inline int VariableDescription::dimensions_size() const {
  return _internal_dimensions_size();
}
inline void VariableDescription::clear_dimensions() {
  _impl_.dimensions_.Clear();
}
inline uint64_t VariableDescription::_internal_dimensions(int index) const {
  return _impl_.dimensions_.Get(index);
}
inline uint64_t VariableDescription::dimensions(int index) const {
  // @@protoc_insertion_point(field_get:tcp_io_device.VariableDescription.dimensions)
  return _internal_dimensions(index);
}
inline void VariableDescription::set_dimensions(int index, uint64_t value) {
  _impl_.dimensions_.Set(index, value);
  // @@protoc_insertion_point(field_set:tcp_io_device.VariableDescription.dimensions)
}
inline void VariableDescription::_internal_add_dimensions(uint64_t value) {
  _impl_.dimensions_.Add(value);
}
inline void VariableDescription::add_dimensions(uint64_t value) {
  _internal_add_dimensions(value);
  // @@protoc_insertion_point(field_add:tcp_io_device.VariableDescription.dimensions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
VariableDescription::_internal_dimensions() const {
  return _impl_.dimensions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
VariableDescription::dimensions() const {
  // @@protoc_insertion_point(field_list:tcp_io_device.VariableDescription.dimensions)
  return _internal_dimensions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
VariableDescription::_internal_mutable_dimensions() {
  return &_impl_.dimensions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
VariableDescription::mutable_dimensions() {
  // @@protoc_insertion_point(field_mutable_list:tcp_io_device.VariableDescription.dimensions)
  return _internal_mutable_dimensions();
}

// -------------------------------------------------------------------

// ProtoVariable

// .tcp_io_device.VariableDescription metaData = 1;
inline bool ProtoVariable::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool ProtoVariable::has_metadata() const {
  return _internal_has_metadata();
}
inline void ProtoVariable::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
inline const ::tcp_io_device::VariableDescription& ProtoVariable::_internal_metadata() const {
  const ::tcp_io_device::VariableDescription* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::tcp_io_device::VariableDescription&>(
      ::tcp_io_device::_VariableDescription_default_instance_);
}
inline const ::tcp_io_device::VariableDescription& ProtoVariable::metadata() const {
  // @@protoc_insertion_point(field_get:tcp_io_device.ProtoVariable.metaData)
  return _internal_metadata();
}
inline void ProtoVariable::unsafe_arena_set_allocated_metadata(
    ::tcp_io_device::VariableDescription* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tcp_io_device.ProtoVariable.metaData)
}
inline ::tcp_io_device::VariableDescription* ProtoVariable::release_metadata() {
  
  ::tcp_io_device::VariableDescription* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tcp_io_device::VariableDescription* ProtoVariable::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:tcp_io_device.ProtoVariable.metaData)
  
  ::tcp_io_device::VariableDescription* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::tcp_io_device::VariableDescription* ProtoVariable::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::tcp_io_device::VariableDescription>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::tcp_io_device::VariableDescription* ProtoVariable::mutable_metadata() {
  ::tcp_io_device::VariableDescription* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:tcp_io_device.ProtoVariable.metaData)
  return _msg;
}
inline void ProtoVariable::set_allocated_metadata(::tcp_io_device::VariableDescription* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:tcp_io_device.ProtoVariable.metaData)
}

// bytes data = 2;
inline void ProtoVariable::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ProtoVariable::data() const {
  // @@protoc_insertion_point(field_get:tcp_io_device.ProtoVariable.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoVariable::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tcp_io_device.ProtoVariable.data)
}
inline std::string* ProtoVariable::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tcp_io_device.ProtoVariable.data)
  return _s;
}
inline const std::string& ProtoVariable::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ProtoVariable::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoVariable::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoVariable::release_data() {
  // @@protoc_insertion_point(field_release:tcp_io_device.ProtoVariable.data)
  return _impl_.data_.Release();
}
inline void ProtoVariable::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tcp_io_device.ProtoVariable.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tcp_io_device

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tcp_io_device::TCPMessage_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tcp_io_device::TCPMessage_Type>() {
  return ::tcp_io_device::TCPMessage_Type_descriptor();
}
template <> struct is_proto_enum< ::tcp_io_device::VariableDescription_DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tcp_io_device::VariableDescription_DataType>() {
  return ::tcp_io_device::VariableDescription_DataType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tcp_5fdata_5fmessage_2eproto
