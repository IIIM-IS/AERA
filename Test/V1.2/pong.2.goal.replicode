; Similar to pong.1.replicode a debug combinations of CTPX, GTPX and PTPX; goal-driven
; Here the ball travels without walls at a constant speed

;(apparently unnecessary) !load drives.replicode

;;;;;;;;;;;;;
;; objects ;;
b:(ent 1)
[
[]; view
   SYNC_ONCE; sync (synchronization mode)
   now;       injection time
   1;         saliency
   forever;   resilience
   root;      group
   nil;       origin
]; Set of views
ball:(ont 1) [[SYNC_ONCE now 0 forever root nil]]
b_is_a_ball:(mk.val b essence ball 1) |[]
; Even though (fact b_is_a_ball ::) is not used in this file, the pattern extractor needs it.
f_b_is_a_ball:(fact b_is_a_ball 0us MAX_TIME 1 1) [[SYNC_AXIOM now 1 forever stdin nil]]

; Create a second ball, b2. We will set a goal for the position and AERA will derive a subgoal to set the speed.
b2:(ent 1) [[SYNC_ONCE now 1 forever root nil]]
b2_is_a_ball:(mk.val b2 essence ball 1) |[]
f_b2_is_a_ball:(fact b2_is_a_ball 0us MAX_TIME 1 1) [[SYNC_AXIOM now 1 forever stdin nil]]

cst_ball_position:(cst |[]
[]
   (fact (mk.val v0: position_y v1: :) v2: v3: : :)
   (fact (mk.val v0: essence ball :) v2: v3: : :)
|[]
|[]
[stdin]
1
) [[SYNC_ONCE now 0 forever primary nil 1]]

;m_run_k:(mdl |[] []
;   (fact (cmd grab_hand [b: y:] ::) t0: t1: ::)
;   ;(fact (icst cst_ball_position |[] [b: :] : :) t0: t1: : :)
;   (fact (mk.val b: position_y y: :) t0: t1: ::)
;|[]
;|[]
;[stdin drives] 1 1 1 0 1) [[SYNC_ONCE now 0 forever primary nil 1]]

m_run_k_template:(mdl |[]
[]
   (fact (cmd grab_hand [b: y:] ::) t0: t1: ::)
   ;(fact (icst cst_ball_position |[] [b: :] : :) t0: t1: : :)
   (fact (mk.val b: position_y y: :) t0: t1: ::)
|[]
|[]
[stdin drives] 1 1 1 0 1) [[SYNC_ONCE now 0 forever primary nil 1]]

m_goal_position:(mdl
|[]; template arguments
[]; LHS and RHS patterns of the model
   (fact (mk.val b2 position_y 111 :) t0: t1: ::); LHS
   (fact run t0: t1: ::);                 drive. RHS
|[]; forward guards
|[]; backward guards
[stdin drives]; output groups
1; strength of the model
1; number of evidences
1; success rate
0; derivative of the success rate
1; psln_tr (saliency change propagation threshold)
) [[SYNC_ONCE now 1 forever primary nil 1]]

;;;;;;;;;;;;;;;;;;;;;;
;; input generators ;;

; This program runs once to set the initial position_y at 0, and speed_y at 0.0001.
; The initial position_y is a fact at some time from now until now plus the sampling_period.
; The initial speed_y is a fact at any time from now until MAX_TIME.
start:(pgm |[] |[] |[] []
   (prb [1 "print" "starting..." |[]])
   (inj []
      p:(mk.val b position_y 0 1)
      |[]
   )
   (inj []
      (fact p after:(now) (+ after sampling_period) 1 1)
      [SYNC_PERIODIC now 1 1 stdin nil]
   )
   (inj []
      s:(mk.val b speed_y 0.0001 1)
      |[]
   )
   (inj []
      (fact s now MAX_TIME 1 1)
      [SYNC_HOLD now 1 forever stdin nil]
   )
1) |[]

istart:(ipgm start |[] RUN_ONCE sampling_period VOLATILE SILENT 1) [[SYNC_ONCE now 0 forever stdin nil 1]]

; This program simulates the environment where b moves at constant speed changing position_y every sampling_period.
; If AERA were connected through I/O to the environment, this would not be necessary.
pgm0:(pgm
|[]; template arguments
[];  patterns defining the inputs
   (ptn f:(fact (mk.val b position_y py: :) after: before: ::) |[])
   (ptn (fact (mk.val b speed_y sy: :) ::) |[])
|[]; guards
[];  productions
   (inj []
      p:(mk.val b position_y (+ py (* sy sampling_period)) 1); The new position_y is the starting position plus speed times the sampling_period.
      |[]
   )
   (inj []
      (fact p (+ after sampling_period) (+ before sampling_period) 1 1); The new position_y is a fact at some time as the starting position plus the sampling_period.
      [SYNC_PERIODIC (+ f.vw.ijt sampling_period) 1 1 stdin nil]; f.vw.ijt gets the inject time of the fact f.
   )
   (prb [1 "print" "updated the position..." [p]]); Can be useful to change usr_operators\Callbacks\callbacks.cpp to print only objects[0]->code(3).asFloat()
   (inj []
      imdl_m_run_k_template:(imdl m_run_k_template [456] |[] false 1) |[]
   )
   (inj []
      (fact imdl_m_run_k_template after before 1 1)
      [SYNC_ONCE now 1 forever primary nil]
   )
   (inj []
      f_run:(fact run after before 1 1)
      |[]
   )
   (inj []
      g:(goal f_run self 1)
      |[]
   )
   (inj []
      (fact g t1:(now) t1 1 1)
      [SYNC_ONCE t1 1 forever primary nil]
   )
1) |[]

; This program has ACTIVATION=1 and will thus run.
ipgm0:(ipgm
pgm0;       the code
|[];        instantiation values
RUN_ALWAYS; boolean RUN_ALWAYS/ONCE
20000us;   time scope
VOLATILE;
NOTIFY;     notify flag
1) [[SYNC_ONCE now 0 forever stdin nil 1]]
